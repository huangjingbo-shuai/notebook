# 函数
## 函数的定义
    + 返回值类型
    + 函数名
    + 参数列表
    + 函数体语句
    + return表达式
1. 语法：![alt text](./.assets_IMG/C++/image.png)
2. ``int add（int num1,int num2）{
    int sum = num1 + num2;
    return sum;
}``
## 函数的调用
+ 函数调用语法：函数名称（参数）
![alt text](./.assets_IMG/C++/image-20.png)
+ 在函数定义的时候，num1和num2并没有真实的数据，只是一个形式上的参数，简称形参。
+ a和b称为 实际参数，简称实参。
+ 当调用函数的是时候，实参的值会传递给形参。
## 值传递
+ 所谓值传递，就是函数调用时实参将数值传入给形参
+ 值传递时，如果形参发生变化，并不会影响实参。
![实例](./.assets_IMG/C++/image-21.png)
![alt text](./.assets_IMG/C++/image-22.png)
## 常见的样式
1. 无参数，无返回
2. 有参数，无返回
3. 无参数，有返回
4. 有参数，有返回
![样式](./.assets_IMG/C++/image-23.png)
## 函数的声明
+ 作用：告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。
+ 声明可以写多次，但是定义只能有一次。
+ 声明是为了告诉编译器这个函数存在，不会报错，保证函数的顺利运行。
![声明](./.assets_IMG/C++/image-24.png)
## 函数的分文件编写
+ 作用：让代码结构更加清晰。函数分文件编写一般有4个步骤。
1. 创建后缀名为`.h`的头文件。
2. 创建后缀名为`.cpp`的源文件。
3. 在头文件中写函数的声明。
4. 在源文件中写函数的定义。
![头文件](./.assets_IMG/C++/image-25.png)
![源文件](./.assets_IMG/C++/image-26.png)
5. 在其他源文件中只需要把函数的头文件名称包含进去，就可以调用该函数了。一般在头部写`#include “头文件名称.h”`即可。
# 重要！！！！！！！！！！！！！
***
***
# 指针
## 指针的基本概念
1. 指针的作用：可以通过指针间接访问内存。
    + 内存编号是从0开始记录的，一般用十六进制数字表示
    + 可以利用指针变量保存地址
2. 定义指针
    + 指针定义的语法：数据类型*指针变量。
    + 让指针记录变量a的地址用`&`来实现。
  3. 使用指针
    + 可以通过解引用的方式来找到指针指向的内存。即，指针前加一个 * 代表解引用，找到指针指向的内存中的数据。
4. eg.![示例](./.assets_IMG/C++/image-27.png)
## 指针所占内存空间
1. 提问：指针也是一种数据类型，那么这种数据类型占多少内存空间？
+ 在32位系统下，占4个字节，64位下占8个字节。
## 空指针和野指针
1. 空指针：指针变量指向内存中编号为0的空间。
    + 用途：初始化指针变量。![alt text](./.assets_IMG/C++/image-28.png)
    + 注意：空指针的内存是不可以访问的。原因是，0～255之间的内存是系统占用的，因此不可以访问。
2. 野指针：指针变量指向非法的内存空间。
    +  在程序中，尽量避免出现野指针。
![野指针](./.assets_IMG/C++/image-29.png)
## const修饰指针
1. 常量指针![alt text](./.assets_IMG/C++/image-36.png)
    + 特点是：指针的指向可以修改，但是指针指向的值不可以改。
    + eg：![常量指针](./.assets_IMG/C++/image-31.png)
2. 指针常量![alt text](./.assets_IMG/C++/image-38.png)
    + 特点：指针的指向不可以改，指针指向的值可以改。
    + ![指针常量](./.assets_IMG/C++/image-32.png)
3. 修饰常量![alt text](./.assets_IMG/C++/image-39.png)
    + 特点：指针的指向和指针指向的值都不可以改
    + ![修饰常量](./.assets_IMG/C++/image-35.png)
### 辨别是哪种修饰指针的技巧：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量。
### 指针和数组
+ 作用：利用指针访问数组中的元素
## 指针和函数。作用：利用指针作函数参数，可以修改实参的值。
1. 值传递
2. 地址传递
![alt text](./.assets_IMG/C++/image-40.png)
![alt text](./.assets_IMG/C++/image-41.png)
# 结构体
1. 定义：自定义数据类型，一些类型集合组成的一个类型
2. 语法：`struct 类型名称{ 成员列表 }`注意：定义结构体时`struct`关键字不能省略。
3. 创建结构体变量的方法有三种(创建结构体变量时关键字`struct`可以省略)
    + ![alt text](./.assets_IMG/C++/image-42.png)
    + ![alt text](./.assets_IMG/C++/image-43.png)
    + ![alt text](./.assets_IMG/C++/image-44.png)
4. 结构体变量利用操作符`.`来访问成员
### 结构体数组
+ ![alt text](./.assets_IMG/C++/image-45.png)
## 结构体指针
1. 作用：通过指针访问结构体中的成员
  + ***利用操作符->可以通过结构体指针访问结构体中的成员属性***
2. 操作：
   + 创建学生结构体变量
    ![alt text](./.assets_IMG/C++/image-46.png)
   + 通过指针指向结构体变量
    ![alt text](./.assets_IMG/C++/image-47.png)
   + 通过指针访问结构体变量中的数据
    ![alt text](./.assets_IMG/C++/image-48.png)
    ![alt text](./.assets_IMG/C++/image-49.png)
## 结构体嵌套结构体
1. 定义学生的结构体

![alt text](./.assets_IMG/C++/image-50.png)

2. 定义老师的结构体

![alt text](./.assets_IMG/C++/image-51.png)

3. 创建老师

![alt text](./.assets_IMG/C++/image-52.png)
# 结构体作函数参数
+ ***作用：将结构体作为参数向函数中传递***
+ 传递的方式有两种：
    1. 值传递
    2. 地址传递
## 结构体中const使用场景
![alt text](./.assets_IMG/C++/image-54.png)
### 全局区
+ C++中在程序运行前分为全局区和代码区
+ 代码区特点是共享和只读
+ 全局区中存放全局变变量、静态变量、常量
+ 常量区中存放const修饰的全局常量和字符串常量
## 栈区
+ 注意事项：
1. 不要返回局部变量的地址

2. 栈区的数据由编译器管理开辟和释放
## 引用
### 引用的基本使用
1. 作用：给变量起别名
2. 语法：数据类型 &别名 = 原名
3. 优点：可以简化指针修改实参
## 菱形继承
菱形继承概念：  
1. 两个派生类继承同一个基类
2. 又有某个类同时继承这两个派生类
3. 这种继承被称为菱形继承，或者钻石继承  
![alt text](.assets_IMG/C++/image-96.png)
![alt text](.assets_IMG/C++/image-97.png)
4. 菱形继承问题：

        1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
        2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以，当菱形继承时，两个父类拥有相同的数据，需要加以作用域区分
5. 利用虚继承  解决菱形继承的问题
6. 继承之前  加上关键字  virtual  把父类变为虚继承   我们把Animal类称为虚基类
![alt text](.assets_IMG/C++/image-98.png)
# 多态
+ 多态是C++面向对象三大特性之一
+ 多态分为两类：  
    1. 静态多态：函数重载和运算符重载属于静态多态，复用函数名
    2. 动态多态：派生类和虚函数实现运行时多态
+ 静态多态和动态多态区别：  
    1. 静态多态的函数地址早绑定 - 编译阶段确定函数地址
    2. 动态多态的函数地址晚绑定 - 运行阶段确定函数地址
# 多态的原理
![alt text](.assets_IMG/C++/image-99.png)
当在父类中声明了虚函数之后，构成动态，会生成一个指针，指向该父类虚函数表，这个表记录的是父类虚函数的地址，当子类重写父类的虚函数时，子类中的虚函数表内部会替换成子类的虚函数表，从而输出子类的虚函数结果。这也是地址的晚绑定
## 多态案例————计算器类
![ ](.assets_IMG/C++/image-100.png)

案例：  
![alt text](.assets_IMG/C++/image-101.png)
![alt text](.assets_IMG/C++/image-102.png)
## 纯虚函数和抽象类
![alt text](.assets_IMG/C++/image-103.png)
实际代码
![alt text](.assets_IMG/C++/image-104.png)
注意：纯虚函数和虚函数的区别在于，凡是有纯虚函数的类则不能定义出实例对象 ，而没有纯虚函数有虚函数的类可以定义出实例对象。
## 多态案例二-制作饮品
案例描述：  ![alt text](.assets_IMG/C++/image-105.png)
![alt text](.assets_IMG/C++/image-106.png)
![alt text](.assets_IMG/C++/image-107.png)
+ 需要注意的是，父类一定要设定为纯虚函数，子类一定要重写父类函数，并且一定要用指针调用才会从父类中访问子类的函数。
## 虚析构和纯虚析构
1. ![alt text](.assets_IMG/C++/image-108.png)
2. ![alt text](.assets_IMG/C++/image-109.png)
3. 总结： ![alt text](.assets_IMG/C++/image-110.png)
4. 代码实现：  ![alt text](.assets_IMG/C++/image-111.png)  
5. ![alt text](.assets_IMG/C++/image-112.png)
## 电脑组装案例
1. ![alt text](.assets_IMG/C++/image-113.png)
2. 电脑在组装案例的思路整理：

        + 首先需要抽象出零件的父类，写入对应的纯虚函数，以便子类重写纯虚函数。
        + 再抽象出电脑类，定义出三个零件的指针，并建立工作函数，让指针调用子类中重写后的函数。
        + 构建出Intel的子类，因特尔分别有这三种零件，继承上述的三种父类，并定义输出函数。Lenovo也是如此。
        + 编写测试函数，给第一台电脑的零件在堆区创建三个新的指针，再创建第一台电脑，定义第一台电脑的指针指向第一台电脑的对象，将new出来的三种零件传入第一台电脑中。
        + 最后用电脑的指针调用工作函数即可。
+ ![alt text](.assets_IMG/C++/image-114.png)
+ ![alt text](.assets_IMG/C++/image-115.png)
+ ![alt text](.assets_IMG/C++/image-116.png)
+ ![alt text](.assets_IMG/C++/image-117.png)
## 文件操作：写文件
1. ![alt text](.assets_IMG/C++/image-119.png)
2. 5个步骤：![alt text](.assets_IMG/C++/image-120.png)
3. ![alt text](.assets_IMG/C++/image-121.png)